	.globl get_null_pointer
	.text
get_null_pointer:
	pushq %rbp
	movq %rsp, %rbp
	subq $16, %rsp
	movl $0, %r10d
	movslq %r10d, %r11
	movq %r11, -8(%rbp)
	movq -8(%rbp), %rax
	movq %rbp, %rsp
	popq %rbp
	ret
	movl $0, %eax
	movq %rbp, %rsp
	popq %rbp
	ret
	.globl main
	.text
main:
	pushq %rbp
	movq %rsp, %rbp
	subq $96, %rsp

	#este de aqui es el address de x
	leaq -8(%rbp), %r11

	#el puntero ptr que apunta a x
	movq %r11, -16(%rbp)

	movq -16(%rbp), %r10
	ptr
	movq %r10, -24(%rbp)

	call get_null_pointer
	pointer
	movq %rax, -32(%rbp)

	movq -32(%rbp), %r10
	null ptr
	movq %r10, -40(%rbp)
        
        #aqui esta el bug!
	movq -24(%rbp), %r10
	movq %r10, -44(%rbp)

	cmpl $0, -44(%rbp)
	jE .Ltmp.9
	movl $1, -48(%rbp)
	movl -48(%rbp), %r10d
	movl %r10d, -52(%rbp)
	jmp .Ltmp.12
.Ltmp.9:
	movl $2, -56(%rbp)
	movl -56(%rbp), %r10d
	movl %r10d, -52(%rbp)
.Ltmp.12:
	movl -52(%rbp), %r10d
	movl %r10d, -60(%rbp)
	movq -40(%rbp), %r10
	movq %r10, -64(%rbp)
	cmpl $0, -64(%rbp)
	jE .Ltmp.15
	movl $3, -68(%rbp)
	movl -68(%rbp), %r10d
	movl %r10d, -72(%rbp)
	jmp .Ltmp.18
.Ltmp.15:
	movl $4, -76(%rbp)
	movl -76(%rbp), %r10d
	movl %r10d, -72(%rbp)
.Ltmp.18:
	movl -72(%rbp), %r10d
	movl %r10d, -80(%rbp)
	cmpl $1, -60(%rbp)
	movl $0, -84(%rbp)
	setNE -84(%rbp)
	movl -84(%rbp), %r10d
	movl %r10d, -88(%rbp)
	cmpl $0, -88(%rbp)
	jE .Ltmp.22
	movl $5, %eax
	movq %rbp, %rsp
	popq %rbp
	ret
.Ltmp.22:
	movl $0, %eax
	movq %rbp, %rsp
	popq %rbp
	ret
	movl $0, %eax
	movq %rbp, %rsp
	popq %rbp
	ret
	.section	.note.GNU-stack,"",@progbits





ASM Program: [Function get_null_pointer stackOffset: None global: True instructions:[MovSX(Imm(0), Pseudo(tmp.5)), AssType: AssemblyType.QUADWORD Mov(Pseudo(tmp.5), Reg(AX)), ret, AssType: AssemblyType.LONGWORD Mov(Imm(0), Reg(AX)), ret], 

Function main stackOffset: None global: True instructions:[
        
        Lea(Pseudo(x.0), Pseudo(tmp.6)), AssType: AssemblyType.QUADWORD Mov(Pseudo(tmp.6), Pseudo(ptr.1)), Call(get_null_pointer), AssType: AssemblyType.QUADWORD Mov(Reg(AX), Pseudo(tmp.7)), AssType: AssemblyType.QUADWORD Mov(Pseudo(tmp.7), Pseudo(null_ptr.2)), AssType: AssemblyType.QUADWORD Mov(Pseudo(ptr.1), Pseudo(tmp.8)), AssType: AssemblyType.LONGWORD Cmp(Imm(0), Pseudo(tmp.8)), JmpCC(ConcCodeType.E, tmp.9), AssType: AssemblyType.LONGWORD Mov(Imm(1), Pseudo(tmp.10)), AssType: AssemblyType.LONGWORD Mov(Pseudo(tmp.10), Pseudo(tmp.11)), Jmp(tmp.12), Label(tmp.9), AssType: AssemblyType.LONGWORD Mov(Imm(2), Pseudo(tmp.13)), AssType: AssemblyType.LONGWORD Mov(Pseudo(tmp.13), Pseudo(tmp.11)), Label(tmp.12), AssType: AssemblyType.LONGWORD Mov(Pseudo(tmp.11), Pseudo(j.3)), AssType: AssemblyType.QUADWORD Mov(Pseudo(null_ptr.2), Pseudo(tmp.14)), AssType: AssemblyType.LONGWORD Cmp(Imm(0), Pseudo(tmp.14)), JmpCC(ConcCodeType.E, tmp.15), AssType: AssemblyType.LONGWORD Mov(Imm(3), Pseudo(tmp.16)), AssType: AssemblyType.LONGWORD Mov(Pseudo(tmp.16), Pseudo(tmp.17)), Jmp(tmp.18), Label(tmp.15), AssType: AssemblyType.LONGWORD Mov(Imm(4), Pseudo(tmp.19)), AssType: AssemblyType.LONGWORD Mov(Pseudo(tmp.19), Pseudo(tmp.17)), Label(tmp.18), AssType: AssemblyType.LONGWORD Mov(Pseudo(tmp.17), Pseudo(k.4)), AssType: AssemblyType.LONGWORD Cmp(Imm(1), Pseudo(j.3)), AssType: AssemblyType.LONGWORD Mov(Imm(0), Pseudo(tmp.20)), SetCC(ConcCodeType.NE, Pseudo(tmp.20)), AssType: AssemblyType.LONGWORD Mov(Pseudo(tmp.20), Pseudo(tmp.21)), AssType: AssemblyType.LONGWORD Cmp(Imm(0), Pseudo(tmp.21)), JmpCC(ConcCodeType.E, tmp.22), AssType: AssemblyType.LONGWORD Mov(Imm(5), Reg(AX)), ret, Label(tmp.22), AssType: AssemblyType.LONGWORD Mov(Imm(0), Reg(AX)), ret, AssType: AssemblyType.LONGWORD Mov(Imm(0), Reg(AX)), ret]]


TAC Program:[Function: get_null_pointer ([]) instructions:[SignExtend tmp.5 = 0, Return tmp.5, Return 0], Function: main ([]) 

instructions:[tmp.6 = Get Address x.0 , Copy ptr.1 = tmp.6, tmp.7 = get_null_pointer([]), 

Copy null_ptr.2 = tmp.7, 

Copy tmp.8 = ptr.1, 

#aqui voy
JumpIfZero(tmp.8, tmp.9), 

Copy tmp.10 = 1, Copy tmp.11 = tmp.10, 

Jump(tmp.12), 

#Negativo
Label(tmp.9), Copy tmp.13 = 2, Copy tmp.11 = tmp.13, 

Label(tmp.12), 

Copy j.3 = tmp.11, 

Copy tmp.14 = null_ptr.2, JumpIfZero(tmp.14, tmp.15), Copy tmp.16 = 3, Copy tmp.17 = tmp.16, Jump(tmp.18), 

Label(tmp.15), 
Copy tmp.19 = 4, Copy tmp.17 = tmp.19, 

Label(tmp.18), 

Copy k.4 = tmp.17, 

tmp.20 = j.3 _ 1, Copy tmp.21 = tmp.20, JumpIfZero(tmp.21, tmp.22), 

Return 5, 

Label(tmp.22), 

Return 0, Return 0]]


Type derivations







ASM Program: [Static Constant: Alignment = 8 : tmp.14 = c_double(1.0), Static Constant: Alignment = 8 : tmp.15 = c_double(1.0), Static Constant: Alignment = 8 : tmp.16 = c_double(1.0), Static Constant: Alignment = 8 : tmp.17 = c_double(1.0), Static Constant: Alignment = 8 : tmp.18 = c_double(4.0), Function main stackOffset: -92 global: True 

instructions:[AssType: 
AssemblyType.DOUBLE Mov(Data(tmp.14), Stack(-8)), 
AssType: AssemblyType.DOUBLE Mov(Data(tmp.15), Stack(-16)), 
AssType: AssemblyType.DOUBLE Mov(Data(tmp.16), Stack(-24)), 
AssType: AssemblyType.DOUBLE Mov(Data(tmp.17), Stack(-32)),

AssType: AssemblyType.DOUBLE Mov(Stack(-8), Stack(-40)), 

AssType: AssemblyType.DOUBLE Binary(Add, Stack(-16), Stack(-40)), 

AssType: AssemblyType.DOUBLE Mov(Stack(-40), Stack(-48)), AssType: 
AssemblyType.DOUBLE Binary(Add, Stack(-24), Stack(-48)), 

AssType: AssemblyType.DOUBLE Mov(Stack(-48), Stack(-56)), 
AssType: AssemblyType.DOUBLE Binary(Add, Stack(-32), Stack(-56)), 

AssType: AssemblyType.DOUBLE Cmp(Data(tmp.18), Stack(-56)), AssType: AssemblyType.LONGWORD Mov(Imm(0), Stack(-60)), SetCC(ConcCodeTypeUnsigned.NE, Stack(-60)), AssType: AssemblyType.LONGWORD Mov(Stack(-60), Stack(-64)), AssType: AssemblyType.LONGWORD Cmp(Imm(0), Stack(-64)), JmpCC(ConcCodeType.E, tmp.9), AssType: AssemblyType.DOUBLE Mov(Stack(-8), Stack(-72)), AssType: AssemblyType.DOUBLE Binary(Add, Stack(-16), Stack(-72)), AssType: AssemblyType.DOUBLE Mov(Stack(-72), Stack(-80)), AssType: AssemblyType.DOUBLE Binary(Add, Stack(-24), Stack(-80)), AssType: AssemblyType.DOUBLE Mov(Stack(-80), Stack(-88)), AssType: AssemblyType.DOUBLE Binary(Add, Stack(-32), Stack(-88)), AssType: AssemblyType.LONGWORD Cvttsd2si(Stack(-88), Stack(-92)), AssType: AssemblyType.LONGWORD Mov(Stack(-92), Reg(AX)), ret, Label(tmp.9), AssType: AssemblyType.LONGWORD Mov(Imm(0), Reg(AX)), ret]]









ASM Program: [Static Constant: Alignment = 8 : tmp.50 = c_double(1.0), Function pass_parameters_3 stackOffset: -136 global: True instructions:[AssType: AssemblyType.QUADWORD Binary(Sub, Imm(144), Reg(SP)), AssType: AssemblyType.LONGWORD Mov(Reg(DI), Stack(-4)), AssType: AssemblyType.LONGWORD Mov(Reg(SI), Stack(-8)), AssType: AssemblyType.QUADWORD Mov(Reg(DX), Stack(-16)), AssType: AssemblyType.QUADWORD Mov(Reg(CX), Stack(-24)), AssType: AssemblyType.LONGWORD Mov(Reg(R8d), Stack(-28)), AssType: AssemblyType.LONGWORD Mov(Reg(R9d), Stack(-32)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM0), Stack(-40)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM1), Stack(-48)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM2), Stack(-56)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM3), Stack(-64)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM4), Stack(-72)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM5), Stack(-80)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM6), Stack(-88)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM7), Stack(-96)), AssType: AssemblyType.DOUBLE Mov(Stack(16), Reg(XMM14)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM14), Stack(-104)), AssType: AssemblyType.DOUBLE Mov(Stack(24), Reg(XMM14)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM14), Stack(-112)), AssType: AssemblyType.LONGWORD Mov(Stack(32), Reg(R10d)), AssType: AssemblyType.LONGWORD Mov(Reg(R10d), Stack(-116)), AssType: AssemblyType.DOUBLE Mov(Stack(40), Reg(XMM14)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM14), Stack(-128)), AssType: AssemblyType.LONGWORD Mov(Stack(48), Reg(R10d)), AssType: AssemblyType.LONGWORD Mov(Reg(R10d), Stack(-132)), AssType: AssemblyType.LONGWORD Mov(Stack(56), Reg(R10d)), AssType: AssemblyType.LONGWORD Mov(Reg(R10d), Stack(-136)), AssType: AssemblyType.DOUBLE Mov(Data(tmp.50), Reg(XMM0)), ret, AssType: AssemblyType.LONGWORD Mov(Imm(0), Reg(AX)), ret], Static Constant: Alignment = 8 : tmp.53 = c_double(3.0), Static Constant: Alignment = 8 : tmp.54 = c_double(2.0), Static Constant: Alignment = 8 : tmp.55 = c_double(3.0), Static Constant: Alignment = 8 : tmp.56 = c_double(4.0), Static Constant: Alignment = 8 : tmp.57 = c_double(5.0), Static Constant: Alignment = 8 : tmp.58 = c_double(6.0), Static Constant: Alignment = 8 : tmp.59 = c_double(6.0), Static Constant: Alignment = 8 : tmp.60 = c_double(7.0), Static Constant: Alignment = 8 : tmp.61 = c_double(8.0), Static Constant: Alignment = 8 : tmp.62 = c_double(9.0), Static Constant: Alignment = 8 : tmp.63 = c_double(10.0), Function main stackOffset: -212 global: True instructions:[AssType: AssemblyType.QUADWORD Binary(Sub, Imm(224), Reg(SP)), AssType: AssemblyType.QUADWORD Mov(Imm(2), Reg(R11d)), AssType: AssemblyType.QUADWORD Cmp(Imm(0), Reg(R11d)), JmpCC(ConcCodeType.L, tmp.51), AssType: AssemblyType.QUADWORD Mov(Imm(2), Reg(R10d)), AssType: AssemblyType.QUADWORD Cvtsi2sd(Reg(R10d), Reg(XMM15)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM15), Stack(-8)), Jmp(tmp.52), Label(tmp.51), AssType: AssemblyType.QUADWORD Mov(Imm(2), Reg(AX)), AssType: AssemblyType.QUADWORD Mov(Reg(AX), Reg(DX)), AssType: AssemblyType.QUADWORD Unary(Shr, Reg(DX)), AssType: AssemblyType.QUADWORD Binary(And, Imm(1), Reg(AX)), AssType: AssemblyType.QUADWORD Binary(Or, Reg(AX), Reg(DX)), AssType: AssemblyType.QUADWORD Cvtsi2sd(Reg(DX), Reg(XMM15)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM15), Stack(-8)), AssType: AssemblyType.DOUBLE Mov(Stack(-8), Reg(XMM15)), AssType: AssemblyType.DOUBLE Binary(Add, Stack(-8), Reg(XMM15)), Label(tmp.52), AssType: AssemblyType.DOUBLE Mov(Stack(-8), Reg(XMM14)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM14), Stack(-16)), AssType: AssemblyType.DOUBLE Mov(Data(tmp.53), Reg(XMM14)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM14), Stack(-24)), AssType: AssemblyType.DOUBLE Mov(Stack(-16), Reg(XMM15)), AssType: AssemblyType.DOUBLE Cmp(Stack(-24), Reg(XMM15)), AssType: AssemblyType.LONGWORD Mov(Imm(0), Stack(-28)), SetCC(ConcCodeTypeUnsigned.A, Stack(-28)), AssType: AssemblyType.LONGWORD Cvtsi2sd(Stack(-28), Reg(XMM15)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM15), Stack(-40)), AssType: AssemblyType.DOUBLE Mov(Stack(-40), Reg(XMM14)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM14), Stack(-48)), AssType: AssemblyType.DOUBLE Mov(Data(tmp.54), Reg(XMM14)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM14), Stack(-56)), AssType: AssemblyType.LONGWORD Mov(Imm(101), Stack(-60)), AssType: AssemblyType.DOUBLE Mov(Data(tmp.55), Reg(XMM14)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM14), Stack(-72)), AssType: AssemblyType.DOUBLE Mov(Data(tmp.56), Reg(XMM14)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM14), Stack(-80)), AssType: AssemblyType.DOUBLE Mov(Data(tmp.57), Reg(XMM14)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM14), Stack(-88)), AssType: AssemblyType.DOUBLE Mov(Data(tmp.58), Reg(XMM14)), AssType: AssemblyType.DOUBLE Mov(Reg(XMM14), Stack(-96)), AssType: AssemblyType.LONGWORD Mov(Imm(104), Stack(-100)), AssType: AssemblyType.LONGWORD Mov(Stack(-100), Reg(R10d)), AssType: AssemblyType.LONGWORD Mov(Reg(R10d), Stack(-104)), AssType: AssemblyType.LONGWORD Mov(Imm(202), Reg(R10d)), MovSX(Reg(R10d), Reg(R11d)),




IntArgs: [(Pseudo(i1.2), AssemblyType.LONGWORD), (Pseudo(i2.7), AssemblyType.LONGWORD), (Pseudo(i3.8), AssemblyType.QUADWORD), (Pseudo(i4.11), AssemblyType.QUADWORD), (Pseudo(i5.13), AssemblyType.LONGWORD), (Pseudo(i6.15), AssemblyType.LONGWORD)]

DoubleArgs: [Pseudo(d1.0), Pseudo(d2.1), Pseudo(d3.3), Pseudo(d4.4), Pseudo(d5.5), Pseudo(d6.6), Pseudo(d7.9), Pseudo(d8.10)]

StackArgs: [(Pseudo(d9.12), AssemblyType.DOUBLE), (Pseudo(d10.14), AssemblyType.DOUBLE), (Pseudo(i7.16), AssemblyType.LONGWORD), (Pseudo(d11.17), AssemblyType.DOUBLE), (Pseudo(i8.18), AssemblyType.LONGWORD), (Pseudo(i9.19), AssemblyType.LONGWORD)]






Int -> unsigned int

positivo cuando no cambian valor



Long -> unsigned long


tmp.67
        LONGWORD








ASM Program: [Function main stackOffset: -24 global: True instructions:[AssType: AssemblyType.LONGWORD Mov(Imm(2), Reg(R10d)), MovSX(Reg(R10d), Reg(R11d)), AssType: AssemblyType.QUADWORD Mov(Reg(R11d), Stack(-8)), AssType: AssemblyType.QUADWORD Mov(Stack(-8), Reg(R10d)), AssType: AssemblyType.QUADWORD Mov(Reg(R10d), Stack(-16)), AssType: AssemblyType.QUADWORD Mov(Stack(-16), Reg(R11d)), AssType: AssemblyType.QUADWORD Mov(Imm(4294967295), Reg(R10d)), AssType: AssemblyType.QUADWORD Binary(Mult, Reg(R10d), Reg(R11d)), AssType: AssemblyType.QUADWORD Mov(Reg(R11d), Stack(-16)), AssType: AssemblyType.LONGWORD Mov(Stack(-16), Reg(R10d)), AssType: AssemblyType.LONGWORD Mov(Reg(R10d), Stack(-20)), AssType: AssemblyType.LONGWORD Mov(Stack(-20), Reg(R10d)), AssType: AssemblyType.LONGWORD Mov(Reg(R10d), Stack(-24)), AssType: AssemblyType.LONGWORD Mov(Imm(0), Reg(AX)), ret, AssType: AssemblyType.LONGWORD Mov(Imm(0), Reg(AX)), ret]]

AST Program:
        VarDecl: NULL int a
        VarDecl: NULL int a
        FunDecl: STATIC sign_extend (i.0, expected.1, ) ParamTypes: (int, long, ) ReturnType: long
                Declaration:
                VarDecl: NULL long extended.2 = (long) i.0, int, long
                Statement: Expression: extended.2, long = (long) (i.0, int GREATERTHAN 4, int, int) ? 3, int : 2, int, int, long, long
                Statement: return (long) extended.2, long AND expected.1, long, int, long
        VarDecl: EXTERN long r
        VarDecl: EXTERN int q
        VarDecl: EXTERN int i = (int) 2147483648, long, int
        VarDecl: EXTERN long j = 2147483648, long
        VarDecl: EXTERN int k = 2147483647, int
        VarDecl: EXTERN long p = (long) 2147483647, int, long
        FunDecl: NULL main () ParamTypes: () ReturnType: int
                Declaration:
                VarDecl: STATIC long r.3
                Declaration:
                VarDecl: STATIC int q.4
                Declaration:
                VarDecl: STATIC int i.5 = (int) 2147483648, long, int
                Declaration:
                VarDecl: STATIC long j.6 = 2147483648, long
                Declaration:
                VarDecl: STATIC int k.7 = 2147483647, int
                Declaration:
                VarDecl: STATIC long p.8 = (long) 2147483647, int, long
                Statement: while (1, int)
                        Statement: break
                Statement: do while (1, int)
                        Statement: continue
                Statement: for (, , )
                        Statement: if (NOT sign_extend(10, int, 10, long, ), long, int)
                                Statement: return 1, int
                        Statement: if (NOT sign_extend(NEGATE 10, int, int, (long) (a, int GREATERTHAN 4, int, int) ? 3, int : 2, int, int, long, ), long, int)
                                Statement: return 2, int
                        Declaration:
                        VarDecl: NULL long l.9 = (long) 100, int, long
                        Statement: if (l.9, long NOTEQUAL 100, long, int)
                                Statement: return 3, int
                Statement: return 0, int











AST Program: [StorageType.NULL int a = None, StorageType.NULL int a = None, Function: StorageType.STATIC FunType: ParamTypes: [int, long] Return Type: long sign_extend (['i.0', 'expected.1']) Block: [Declaration: StorageType.NULL long extended.2 = ((long) (i.0 RetType: int) RetType: long), Statement: ((extended.2 RetType: long) = ((long) ((Binary Expression: Operator: BinopType.GREATERTHAN Left: (i.0 RetType: int) Right: (4 RetType: int) RetType: int) ? (3 RetType: int) : (2 RetType: int) RetType: int) RetType: long) RetType: long), Statement: return ((long) (Binary Expression: Operator: BinopType.AND Left: (extended.2 RetType: long) Right: (expected.1 RetType: long) RetType: int) RetType: long)], StorageType.EXTERN long r = None, StorageType.EXTERN int q = None, StorageType.EXTERN int i = ((int) (2147483648L RetType: long) RetType: int), StorageType.EXTERN long j = (2147483648L RetType: long), StorageType.EXTERN int k = (2147483647 RetType: int), StorageType.EXTERN long p = ((long) (2147483647 RetType: int) RetType: long), Function: StorageType.NULL FunType: ParamTypes: [] Return Type: int main ([]) Block: [Declaration: StorageType.STATIC long r.3 = None, Declaration: StorageType.STATIC int q.4 = None, Declaration: StorageType.STATIC int i.5 = ((int) (2147483648L RetType: long) RetType: int), Declaration: StorageType.STATIC long j.6 = (2147483648L RetType: long), Declaration: StorageType.STATIC int k.7 = (2147483647 RetType: int), Declaration: StorageType.STATIC long p.8 = ((long) (2147483647 RetType: int) RetType: long), Statement: for None (Declaration: StorageType.NULL int m.9 = (0 RetType: int) ; (Binary Expression: Operator: BinopType.LESSTHAN Left: (m.9 RetType: int) Right: (4 RetType: int) RetType: int) ; ((m.9 RetType: int) = (Binary Expression: Operator: BinopType.ADD Left: (m.9 RetType: int) Right: (1 RetType: int) RetType: int) RetType: int)) thenS: Block: None, Statement: if ((Unary Expression: Operator: UnopType.NOTExpression: (sign_extend([(10 RetType: int), (10L RetType: long)]) RetType: long) RetType: int)) thenS: Block: [Statement: return (1 RetType: int)] elseS: None, Statement: if ((Unary Expression: Operator: UnopType.NOTExpression: (sign_extend([(Unary Expression: Operator: UnopType.NEGATEExpression: (10 RetType: int) RetType: int), ((long) ((Binary Expression: Operator: BinopType.GREATERTHAN Left: (a RetType: int) Right: (4 RetType: int) RetType: int) ? (3 RetType: int) : (2 RetType: int) RetType: int) RetType: long)]) RetType: long) RetType: int)) thenS: Block: [Statement: return (2 RetType: int)] elseS: None, Declaration: StorageType.NULL long l.10 = ((long) (100 RetType: int) RetType: long), Statement: if ((Binary Expression: Operator: BinopType.NOTEQUAL Left: (l.10 RetType: long) Right: (100L RetType: long) RetType: int)) thenS: Block: [Statement: return (3 RetType: int)] elseS: None, Statement: return (0 RetType: int)]]




{'a': a int InitialVal: <typeChecker.Tentative object at 0x7f9c3bf31820> Global: True, 'sign_extend': sign_extend FunType: ParamTypes: [int, long] Return Type: long Defined: True Global: False, 'i.0': i.0 int <typeChecker.LocalAttributes object at 0x7f9c3bf31940>, 'expected.1': expected.1 long <typeChecker.LocalAttributes object at 0x7f9c3bf319a0>, 'extended.2': extended.2 long <typeChecker.LocalAttributes object at 0x7f9c3bf31910>, 'r': r long InitialVal: <typeChecker.NoInitializer object at 0x7f9c3bf31f70> Global: True, 'q': q int InitialVal: <typeChecker.NoInitializer object at 0x7f9c3bf32090> Global: True, 'i': i int InitialVal: -2147483648 Global: True, 'j': j long InitialVal: 2147483648 Global: True, 'k': k int InitialVal: 2147483647 Global: True, 'p': p long InitialVal: 2147483647 Global: True, 'main': main FunType: ParamTypes: [] Return Type: int Defined: True Global: True, 'r.3': r.3 long InitialVal: 0 Global: False, 'q.4': q.4 int InitialVal: 0 Global: False, 'i.5': i.5 int InitialVal: -2147483648 Global: False, 'j.6': j.6 long InitialVal: 2147483648 Global: False, 'k.7': k.7 int InitialVal: 2147483647 Global: False, 'p.8': p.8 long InitialVal: 2147483647 Global: False, 'm.9': m.9 int <typeChecker.LocalAttributes object at 0x7f9c3bf0db80>, 'l.10': l.10 long <typeChecker.LocalAttributes object at 0x7f9c3bf38320>}



Statement: 
(
    #left
    (extended.2 RetType: long) = 
    #right
    (
        (long) (    
                    #cond Exp
                    (
                        Binary Expression: Operator: BinopType.GREATERTHAN 
                            Left: (i.0 
                            RetType: int) 
                            Right: (4 
                            RetType: int) 

                    RetType: int) 

                    ? 
                    #then Exp
                    (3 RetType: int) 
                    :
                    #else Exp 
                    (2 RetType: int) 
                
                #Conditional Expression int
                RetType: int) 
        RetType: long) 
    
RetType: long)


 = 2^31

sign extend

Truncate

movl ecx, eax


18 + 5 + 6

29


entry
    name
    attrs
    type

    StaticAttributes 
        Init 
            Tentative
            Initial


Si la viejita es global 



prev not tiene linkage or nueva no es extern:
    
not (prev_entry.has_linkage and decl.storage_class == Extern)


Has linkage or not


AST Program: [Function: foo ([]) Block: None, Function: main ([]) Block: [
    
    Declaration: Function: a ([]) Block: None
    
    , Statement: for None (Declaration: a = None ; None ; None) thenS: Block: None, Statement: return foo], foo = None, foo = 4]

{}

AST Program: [Function: foo ([]) Block: None, Function: main ([]) Block: [
    
    Declaration: Function: a ([]) Block: None

    , Statement: for None (Declaration: a = None ; None ; None) thenS: Block: None, Statement: return foo], foo = None, foo = 4]

;


All external variables are static

external subset of static




Necesitas si 

caller -> callee
        el callee

24
8
8
16
8


8
8
8
8

a + g


8 bytes puntero a el return instruction address


32
//7
add 32 rbp, eax



Osea si se puede ghosting, no 

So field type is identifier and the name main

identifier -> main
statement -> body

    .globl main
main:
 pushq %rbp
 movq %rsp, %rbp
 subq $8, %rsp
 1 movl $2, 2 -4(%rbp)
 3 negl -4(%rbp)
 4 movl -4(%rbp), %r10d
 5 movl %r10d, -8(%rbp)
 6 notl -8(%rbp)
 7 movl -8(%rbp), %eax
 movq %rbp, %rsp
 popq %rbp
 ret

 0xffffda60
 

 0x7fffffffd508

previous stackframe
 rbp - address

 rsp - last_val

 //stack frame
 rbp - address ->rbp
       val0
 rsp - val1

inner most expression and working our way out!
tmp.0 = -8
tmp.1 = ~tmp.0 
tmp.2 = -tmp.1
return tmp.2

insert (actual, offset)
buscas 
usas

insertas
usas

parent->next = newStackOperand
newStackOperand->next  = actual->next


(actual, offset - 0)
actual2, offset - 4
actual3, offset - 8

actual, reg

reg    , other


+ - * % /
left associative

precedence
* / %
+ - 

subl a, b

b = b - a


--------------------------------------

a / b b is the divisor

    


a = RDX RAX
idivq b

a = EDX EAX
idivl b 

EDX = quotient
EAX = remainder

-------------------------------------------

Sign extension

